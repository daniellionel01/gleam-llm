[[{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"g_p_t4o","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"o4mini","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"claude37_sonnet","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"claude_sonnet4","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gemini25flash","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gemini25pro","eval":"valid"}],[{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  defer(do_hello())\n  io.println(\"1\")\n}\n\npub fn defer(action: fn() -> ()) -> Nil {\n  use _ <- action()\n  Nil\n}\n\nfn do_hello() -> () {\n  io.println(\"hello\")\n}","model":"g_p_t4o","eval":"compile_error"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(thunk: fn() -> Nil, f: fn(Nil) -> Nil) -> Nil {\n  f(Nil)\n  thunk()\n}\n\npub fn main() -> Nil {\n  use _ <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"o4mini","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  use <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}\n\npub fn defer(f: fn() -> a, callback: fn() -> b) -> b {\n  let result = callback()\n  f()\n  result\n}","model":"claude37_sonnet","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(callback: fn() -> Nil, continuation: fn() -> a) -> a {\n  let result = continuation()\n  callback()\n  result\n}\n\npub fn main() {\n  use <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"claude_sonnet4","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(cleanup_fn: fn() -> Nil) -> fn(fn() -> a) -> a {\n  fn(main_body: fn() -> a) -> a {\n    let result = main_body()\n    cleanup_fn()\n    result\n  }\n}\n\npub fn main() {\n  io.println(\"Program start\")\n\n  use _ <- defer(fn() {\n    io.println(\"hello\")\n  }) {\n    io.println(\"1\")\n    Nil\n  }\n\n  io.println(\"Program end\")\n}","model":"gemini25flash","eval":"compile_error"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\nfn defer(action: fn() -> a) -> fn(fn() -> b) -> b {\n  fn(callback: fn() -> b) -> b {\n    let result = callback()\n    let _ = action()\n    result\n  }\n}\n\npub fn main() {\n  use <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"gemini25pro","eval":"compile_error"}],[{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [row, ..rest] ->\n      row\n      |> list.map(fn(_, idx) {\n        row |> list.concat(list.map(rest, fn(r) { [r[idx]] }))\n      })\n  }\n}\n\npub fn main() {\n  io.println(transpose([[1, 2, 3], [4, 5, 6]]))\n}","model":"g_p_t4o","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [first, ..] ->\n      case first {\n        [] -> []\n        _ ->\n          let heads = list.map(matrix, fn(row) {\n            case row {\n              [h, ..] -> h\n              [] -> 0\n            }\n          })\n          let tails = list.map(matrix, fn(row) {\n            case row {\n              [_, ..r] -> r\n              [] -> []\n            }\n          })\n          [heads, ..transpose(tails)]\n      }\n  }\n}\n\npub fn main() {\n  echo transpose([[1, 2, 3], [4, 5, 6]])\n}","model":"o4mini","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\nimport gleam/string\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  let transposed = transpose(matrix)\n  \n  transposed\n  |> list.map(fn(row) {\n    row\n    |> list.map(string.inspect)\n    |> string.join(\", \")\n  })\n  |> string.join(\"\\n\")\n  |> io.println\n}\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[], ..] -> []\n    _ -> {\n      let first_row = list.first(matrix)\n        |> list.unwrap([])\n        \n      let column_count = list.length(first_row)\n      \n      list.range(0, column_count - 1)\n      |> list.map(fn(col_index) {\n        matrix\n        |> list.map(fn(row) {\n          list.at(row, col_index)\n          |> list.unwrap(0)\n        })\n      })\n    }\n  }\n}","model":"claude37_sonnet","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\nimport gleam/int\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[] | _] -> []\n    _ -> {\n      let heads = list.map(matrix, fn(row) {\n        case row {\n          [head | _] -> head\n          [] -> 0\n        }\n      })\n      let tails = list.map(matrix, fn(row) {\n        case row {\n          [_ | tail] -> tail\n          [] -> []\n        }\n      })\n      [heads | transpose(tails)]\n    }\n  }\n}\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  let transposed = transpose(matrix)\n  io.debug(transposed)\n}","model":"claude_sonnet4","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\nfn get_current_column(matrix: List(List(Int))) -> List(Int) {\n  list.filter_map(matrix, fn(row) {\n    case row {\n      [head, .._] -> Ok(head)\n      [] -> Error(Nil)\n    }\n  })\n}\n\nfn get_remaining_matrix(matrix: List(List(Int))) -> List(List(Int)) {\n  list.map(matrix, fn(row) {\n    case row {\n      [_head, ..tail] -> tail\n      [] -> []\n    }\n  })\n}\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    _ -> {\n      let current_column = get_current_column(matrix)\n      case current_column {\n        [] -> []\n        _ -> {\n          let remaining_matrix = get_remaining_matrix(matrix)\n          [current_column, ..transpose(remaining_matrix)]\n        }\n      }\n    }\n  }\n}\n\npub fn main() {\n  let matrix_to_transpose = [[1, 2, 3], [4, 5, 6]]\n  let transposed_result = transpose(matrix_to_transpose)\n  io.println(transposed_result)\n}","model":"gemini25flash","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\nimport gleam/result\n\nfn transpose(matrix: List(List(a))) -> List(List(a)) {\n  case list.traverse(matrix, list.first) {\n    Error(_) -> []\n    Ok(heads) -> {\n      let tails = list.map(matrix, fn(row) {\n        case row {\n          [_, ..tail] -> tail\n          [] -> []\n        }\n      })\n      [heads, ..transpose(tails)]\n    }\n  }\n}\n\npub fn main() {\n  echo(transpose([[1, 2, 3], [4, 5, 6]]))\n}","model":"gemini25pro","eval":"compile_error"}]]