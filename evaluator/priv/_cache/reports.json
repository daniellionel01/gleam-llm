[[{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gpt5","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gpt4o","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"o4mini","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"claude37_sonnet","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"claude_sonnet4","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gemini25flash","eval":"valid"},{"case_":{"id":"hello","title":"Hello World!","contents":"A program that outputs 'hello, world!'","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"hello, world!\")\n}","model":"gemini25pro","eval":"valid"}],[{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(action: fn() -> Nil, next: fn(Nil) -> a) -> a {\n  let result = next(Nil)\n  action()\n  result\n}\n\npub fn main() {\n  use _ <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"gpt5","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  use _ <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}\n\npub fn defer(action: fn() -> Nil) -> fn(fn() -> result_type) -> result_type {\n  fn(callback) {\n    let result = callback()\n    action()\n    result\n  }\n}","model":"gpt4o","eval":"compile_error"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(block: fn() -> a) -> a {\n  let res = block()\n  io.println(\"hello\")\n  res\n}\n\npub fn main() {\n  use <- defer\n  io.println(\"1\")\n}","model":"o4mini","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn main() {\n  io.println(\"1\")\n  use <- defer(fn() { io.println(\"hello\") })\n  Nil\n}\n\npub fn defer(f: fn() -> a) -> fn(fn() -> b) -> b {\n  fn(g) {\n    let result = g()\n    let _ = f()\n    result\n  }\n}","model":"claude37_sonnet","eval":"compile_error"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(cleanup: fn() -> Nil, callback: fn() -> a) -> a {\n  let result = callback()\n  cleanup()\n  result\n}\n\npub fn main() {\n  use <- defer(fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"claude_sonnet4","eval":"valid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(\n  deferred_action: fn() -> Nil,\n  continuation_block: fn(Nil) -> Nil,\n) -> Nil {\n  let _ = continuation_block(Nil)\n  deferred_action()\n}\n\npub fn main() {\n  io.println(\"Program started.\")\n\n  use _ <- defer(fn() { io.println(\"Hello from deferred!\") })\n\n  io.println(\"1\")\n\n  io.println(\"Program finished.\")\n}","model":"gemini25flash","eval":"invalid"},{"case_":{"id":"defer","title":"Defer","contents":"\nA program that demonstrates a 'defer' utility function. Write the function called 'defer' that can be used via the gleam `use` syntax.\nDemonstrate it by deferring a print of 'hello' and printing '1' before.\n","deps":[]},"program":"import gleam/io\n\npub fn defer(action deferred: fn() -> a, callback: fn() -> b) -> b {\n  let result = callback()\n  let _ = deferred()\n  result\n}\n\npub fn main() {\n  use <- defer(action: fn() { io.println(\"hello\") })\n  io.println(\"1\")\n}","model":"gemini25pro","eval":"compile_error"}],[{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\nimport gleam/int\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    _ ->\n      case any_row_empty(matrix) {\n        True -> []\n        False ->\n          let col = heads(matrix)\n          let rest = tails(matrix)\n          [col, ..transpose(rest)]\n      }\n  }\n}\n\nfn any_row_empty(rows: List(List(a))) -> Bool {\n  case rows {\n    [] -> False\n    [first, ..rest] ->\n      case first {\n        [] -> True\n        [_, ..] -> any_row_empty(rest)\n      }\n  }\n}\n\nfn heads(rows: List(List(a))) -> List(a) {\n  case rows {\n    [] -> []\n    [first, ..rest] ->\n      case first {\n        [h, ..] -> [h, ..heads(rest)]\n        [] -> []\n      }\n  }\n}\n\nfn tails(rows: List(List(a))) -> List(List(a)) {\n  case rows {\n    [] -> []\n    [first, ..rest] ->\n      case first {\n        [_, ..t] -> [t, ..tails(rest)]\n        [] -> []\n      }\n  }\n}\n\nfn show_row(row: List(Int)) -> String {\n  \"[\" <> join_ints(row) <> \"]\"\n}\n\nfn join_ints(ints: List(Int)) -> String {\n  list.fold(ints, \"\", fn(acc, e) {\n    let s = int.to_string(e)\n    case acc {\n      \"\" -> s\n      _ -> acc <> \", \" <> s\n    }\n  })\n}\n\nfn show_matrix(matrix: List(List(Int))) -> String {\n  \"[\" <> join_rows(matrix) <> \"]\"\n}\n\nfn join_rows(rows: List(List(Int))) -> String {\n  list.fold(rows, \"\", fn(acc, row) {\n    let s = show_row(row)\n    case acc {\n      \"\" -> s\n      _ -> acc <> \", \" <> s\n    }\n  })\n}\n\npub fn main() {\n  io.println(show_matrix(transpose([[1, 2, 3], [4, 5, 6]])))\n}","model":"gpt5","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [..] ->\n      case list.heads(matrix) {\n        Ok(heads) ->\n          [heads, ..transpose(list.tails(matrix) |> result.unwrap([], fn x -> x))]\n        Error(_) -> []\n      }\n  }\n}\n\npub fn main() {\n  io.println(transpose([[1, 2, 3], [4, 5, 6]]))\n}","model":"gpt4o","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list as list\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[], ..] -> []\n    _ ->\n      let heads = list.map(matrix, fn(r) { case r { [h, ..] -> h; [] -> panic as \"transpose: empty row\" } })\n      let tails = list.map(matrix, fn(r) { case r { [_h, ..t] -> t; [] -> panic as \"transpose: empty row\" } })\n      [heads, ..transpose(tails)]\n  }\n}\n\npub fn main() {\n  io.println(transpose([[1, 2, 3], [4, 5, 6]]))\n}","model":"o4mini","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  let transposed = transpose(matrix)\n  io.println(string_of_matrix(transposed))\n}\n\nfn string_of_matrix(matrix: List(List(Int))) -> String {\n  let rows = list.map(matrix, fn(row) {\n    \"[\" <> list.map(row, fn(n) { int.to_string(n) })\n    |> list.intersperse(\", \")\n    |> string.concat <> \"]\"\n  })\n  \"[\" <> list.intersperse(rows, \", \") |> string.concat <> \"]\"\n}\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[], ..] -> []\n    _ -> {\n      let first_col = list.map(matrix, fn(row) { list.first(row) |> option.unwrap(0) })\n      let rest_matrix = list.map(matrix, fn(row) { \n        case row {\n          [] -> []\n          [_, ..rest] -> rest\n        } \n      })\n      [first_col, ..transpose(rest_matrix)]\n    }\n  }\n}","model":"claude37_sonnet","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\nimport gleam/int\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[] | _] -> []\n    _ -> {\n      let heads = list.map(matrix, fn(row) {\n        case row {\n          [head | _] -> head\n          [] -> 0\n        }\n      })\n      let tails = list.map(matrix, fn(row) {\n        case row {\n          [_ | tail] -> tail\n          [] -> []\n        }\n      })\n      [heads | transpose(tails)]\n    }\n  }\n}\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  let result = transpose(matrix)\n  io.println(int.to_string(list.length(result)))\n}\n\n\nWait, I need to print the actual transposed matrix. Let me fix this:\n\n\nimport gleam/io\nimport gleam/list\nimport gleam/int\nimport gleam/string\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[] | _] -> []\n    _ -> {\n      let heads = list.map(matrix, fn(row) {\n        case row {\n          [head | _] -> head\n          [] -> 0\n        }\n      })\n      let tails = list.map(matrix, fn(row) {\n        case row {\n          [_ | tail] -> tail\n          [] -> []\n        }\n      })\n      [heads | transpose(tails)]\n    }\n  }\n}\n\nfn list_to_string(lst: List(Int)) -> String {\n  \"[\" <> string.join(list.map(lst, int.to_string), \", \") <> \"]\"\n}\n\nfn matrix_to_string(matrix: List(List(Int))) -> String {\n  \"[\" <> string.join(list.map(matrix, list_to_string), \", \") <> \"]\"\n}\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  let result = transpose(matrix)\n  io.println(matrix_to_string(result))\n}","model":"claude_sonnet4","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\npub fn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    [[], .._] -> [] // If the first row is empty, assume all rows are exhausted for columns\n    _ -> {\n      let current_column = list.map(matrix, fn(row) {\n        case row {\n          [head, .._] -> head\n          // This case should not be reached for a rectangular matrix\n          // as all rows would become empty simultaneously, triggering the base case.\n          [] -> panic as \"Attempted to get head of an empty row in a non-empty matrix.\"\n        }\n      })\n\n      let remaining_matrix = list.map(matrix, fn(row) {\n        case row {\n          [_head, ..tail] -> tail\n          [] -> [] // This row is exhausted, pass an empty list\n        }\n      })\n      \n      [current_column, ..transpose(remaining_matrix)]\n    }\n  }\n}\n\npub fn main() {\n  io.println(transpose([[1, 2, 3], [4, 5, 6]]))\n}","model":"gemini25flash","eval":"compile_error"},{"case_":{"id":"matrix","title":"Matrix","contents":"\nWrite a Gleam program that defines a function transpose(matrix: List(List(Int))) -> List(List(Int)) which takes a matrix of integers and returns its transpose.\nThe transpose flips rows into columns, so the element at position (i, j) becomes (j, i).\nInclude a main function that exclusively prints the transpose of [[1, 2, 3], [4, 5, 6]], nothing else.\n","deps":[]},"program":"import gleam/io\nimport gleam/list\n\nfn transpose(matrix: List(List(Int))) -> List(List(Int)) {\n  case matrix {\n    [] -> []\n    _ -> {\n      let heads = list.filter_map(matrix, list.first)\n      let tails = list.filter_map(matrix, list.rest)\n\n      case list.length(heads) < list.length(matrix) {\n        True -> []\n        False -> [heads, ..transpose(tails)]\n      }\n    }\n  }\n}\n\npub fn main() {\n  let matrix = [[1, 2, 3], [4, 5, 6]]\n  io.println(transpose(matrix))\n}","model":"gemini25pro","eval":"compile_error"}]]